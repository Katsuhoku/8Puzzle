begin a*_for_npuzzle
    Root <- initial state readed from file

    open <- [Root] // tree leaves
    closed <- [] // already expanded nodes
    limit <- [] // nodes in the deepest limit level

    while true do
        while open <> [] do
            X <- board with best evaluation from open

            if X is the goal state
                return path from Start to X
            else
                if X si in the deepest limit level then
                    add X to limit // insertion sort
                else
                    children <- children of X
                    for each child in children do
                        // each node is generated sequentially, but the search of the node
                        // in each array is made in parallel
                        // This requires Readers-Writters implementation, priority on Writters
                        // (If this is a duplicated state, then there's one and only one node
                        // that has the same state. Then the other evaluations must be stopped
                        // or canceled. The shared resource then is the flag checked by all nodes
                        // to decide to continue or stop. Checking nodes can access to Read the
                        // value, but the only one node who updates the value has priority to
                        // get the resource.)
                        if child was already in open then // parallel
                            if this is a shorter path to the child then // (i.e. is a better evaluation)
                                update child evaluation
                                update child father node as X
                            end if
                        else if child was already in closed then // parallel
                            if this is a shorter path to the child
                                move child node from close to open
                                delete the subtree that child had
                                update child father node as X
                            end if
                        else if child was already in limit then // parallel
                            if this is a shorter path to the child
                                move child node from limit to open
                                update child evaluation
                                update chid father node as X
                            end if
                        else // the child is not in open nor in closed nor in limit
                            evaluate child
                            add child to open at its corresponding place // insertion sort
                        end if
                    
                    add X to closed
                end if
            end if
        end while

        // at some point, every leaf in the tree will be a limit node
        // then open gets empty and the algorithm starts again giving
        // the best node in limit as the new root
        if limit <> [] then
            newRoot <- board with best evaluation from limit
            open <- [newRoot]
            closed <- []
        else
            break;
        end if
    end while

    // if the solution couldn't be found and there's no more tree to
    // explore then its a fail
    return FAIL
end a*_for_npuzzle

begin evaluate
    evaluation <- level of the node + 0.2 * manhattanDistance + 0.5 * misplacedTiles + 0.3 * permutationInversions
    return evaluation
end evaluate

begin manhattanDistance
    total <- 0
    for each tile in the current state board do
        row_distance <- vertical distance from the current row of the tile to the row of its position in solved state
        column_distance <- horizontal distance from the current column of the tile to the column of its position in solved state

        total <- row_distance + column_distance
    end for

    return total / maxManhattan
end manhattanDistance

begin misplacedTiles
    total <- 0
    for each tile in the current state board do
        if the tile is not the blank space then
            if the tile is not in its position in the solved state then
                total <- total + 1
            end if
        end if
    end for

    return total / maxMisplaced
end misplacedTiles

begin permutationInversions
    total <- 0
    solvedPermutation <- solvedState matrix as a vector, every row is appended one by one in order
    statePermutation <- currentState matrix as a vector, every row is appended one by one in order

    // gets the mapped permutation
    normalizedStatePermutation <- []
    for i from 0 to boardSize ^ 2 increment 1 do
        normalizedStatePermutation[i] <- index of solvedPermutation[i] in statePermutation
    end for

    for each element in normalizedStatePermutation do
        total <- total + number of elements smaller than this element at his right part of the normalizedStatePermutation
    end for

    return total / maxInversions
end permutationInversions

begin generate_children
    let (i, j) be the (row, column) pair of coordinates of the blank space in the current state board
    current <- (i, j)
    
    movements <- [
        right <- (i, j+1),
        up <- (i-1, j),
        left <- (i, j-1),
        down <- (i+1, j)
    ]

    children <- []
    for each movement in movements do
        if the new coordinates of the blank space are in the boundaries of the board then
            newState <- currentState
            newState.switchTiles(current, movement)
            add newState to children
        end if
    end for

    return children
end generate_children